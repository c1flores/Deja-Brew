{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport mapValue from '../jsutils/mapValue';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLDirective } from '../type/directives';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isIntrospectionType } from '../type/introspection';\nimport { assertSchema, GraphQLSchema } from '../type/schema';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n  var typeDefs = [];\n  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExts = [];\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExts.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExts = typeExtsMap[extendedTypeName];\n      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {\n    return schema;\n  }\n  var schemaConfig = schema.toConfig();\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(typeName, \"\\\".\"));\n    }\n    return type;\n  });\n  var typeMap = keyValMap(typeDefs, function (node) {\n    return node.name.value;\n  }, function (node) {\n    return astBuilder.buildType(node);\n  });\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  } // Get the extended root operation types.\n\n  var operationTypes = {\n    query: schemaConfig.query && schemaConfig.query.name,\n    mutation: schemaConfig.mutation && schemaConfig.mutation.name,\n    subscription: schemaConfig.subscription && schemaConfig.subscription.name\n  };\n  if (schemaDef) {\n    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {\n      var _ref2 = _schemaDef$operationT2[_i6];\n      var operation = _ref2.operation;\n      var type = _ref2.type;\n      operationTypes[operation] = type.name.value;\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {\n    var schemaExt = schemaExts[_i8];\n    if (schemaExt.operationTypes) {\n      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {\n        var _ref4 = _schemaExt$operationT2[_i10];\n        var _operation = _ref4.operation;\n        var _type = _ref4.type;\n        operationTypes[_operation] = _type.name.value;\n      }\n    }\n  } // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: getMaybeTypeByName(operationTypes.query),\n    mutation: getMaybeTypeByName(operationTypes.mutation),\n    subscription: getMaybeTypeByName(operationTypes.subscription),\n    types: objectValues(typeMap),\n    directives: getMergedDirectives(),\n    astNode: schemaDef || schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),\n    allowedLegacyNames: allowedLegacyNames\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n    return replaceNamedType(type);\n  }\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n  function getMaybeTypeByName(typeName) {\n    return typeName ? typeMap[typeName] : null;\n  }\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    existingDirectives || devAssert(0, 'schema must have default directives');\n    return existingDirectives.concat(directiveDefs.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    } else if (isScalarType(type)) {\n      return extendScalarType(type);\n    } else if (isObjectType(type)) {\n      return extendObjectType(type);\n    } else if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    } else if (isUnionType(type)) {\n      return extendUnionType(type);\n    } else if (isEnumType(type)) {\n      return extendEnumType(type);\n    } else if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // Not reachable. All possible types have been considered.\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n  function extendDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n  function extendInputObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), {}, keyValMap(fieldNodes, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return astBuilder.buildInputField(field);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendEnumType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[type.name] || [];\n    var valueNodes = flatMap(extensions, function (node) {\n      return node.values || [];\n    });\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, {}, keyValMap(valueNodes, function (value) {\n        return value.name.value;\n      }, function (value) {\n        return astBuilder.buildEnumValue(value);\n      })),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendScalarType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var interfaceNodes = flatMap(extensions, function (node) {\n      return node.interfaces || [];\n    });\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendInterfaceType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendUnionType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var typeNodes = flatMap(extensions, function (node) {\n      return node.types || [];\n    });\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n}","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","flatMap","objectValues","inspect","mapValue","invariant","devAssert","keyValMap","Kind","isTypeDefinitionNode","isTypeExtensionNode","assertValidSDLExtension","GraphQLDirective","isSpecifiedScalarType","isIntrospectionType","assertSchema","GraphQLSchema","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","ASTDefinitionBuilder","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","typeDefs","typeExtsMap","create","directiveDefs","schemaDef","schemaExts","_i2","_documentAST$definiti2","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","extendedTypeName","name","existingTypeExts","concat","DIRECTIVE_DEFINITION","schemaConfig","toConfig","astBuilder","typeName","type","typeMap","undefined","Error","node","buildType","_i4","_schemaConfig$types2","types","existingType","extendNamedType","operationTypes","query","mutation","subscription","_i6","_schemaDef$operationT2","_ref2","operation","_i8","schemaExt","_i10","_schemaExt$operationT2","_ref4","_operation","_type","allowedLegacyNames","getMaybeTypeByName","directives","getMergedDirectives","astNode","extensionASTNodes","replaceType","ofType","replaceNamedType","existingDirectives","getDirectives","map","extendDirective","buildDirective","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","directive","config","args","extendArg","extensions","fieldNodes","fields","field","buildInputField","valueNodes","values","buildEnumValue","interfaceNodes","interfaces","getInterfaces","getNamedType","extendField","buildField","typeNodes","getTypes","arg"],"sources":["C:/Users/Christian Flores/Desktop/Deja-Brew/client/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport mapValue from '../jsutils/mapValue';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLDirective } from '../type/directives';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isIntrospectionType } from '../type/introspection';\nimport { assertSchema, GraphQLSchema } from '../type/schema';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExts = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExts.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExts = typeExtsMap[extendedTypeName];\n      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var schemaConfig = schema.toConfig();\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(typeName, \"\\\".\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyValMap(typeDefs, function (node) {\n    return node.name.value;\n  }, function (node) {\n    return astBuilder.buildType(node);\n  });\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  } // Get the extended root operation types.\n\n\n  var operationTypes = {\n    query: schemaConfig.query && schemaConfig.query.name,\n    mutation: schemaConfig.mutation && schemaConfig.mutation.name,\n    subscription: schemaConfig.subscription && schemaConfig.subscription.name\n  };\n\n  if (schemaDef) {\n    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {\n      var _ref2 = _schemaDef$operationT2[_i6];\n      var operation = _ref2.operation;\n      var type = _ref2.type;\n      operationTypes[operation] = type.name.value;\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {\n    var schemaExt = schemaExts[_i8];\n\n    if (schemaExt.operationTypes) {\n      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {\n        var _ref4 = _schemaExt$operationT2[_i10];\n        var _operation = _ref4.operation;\n        var _type = _ref4.type;\n        operationTypes[_operation] = _type.name.value;\n      }\n    }\n  } // Support both original legacy names and extended legacy names.\n\n\n  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: getMaybeTypeByName(operationTypes.query),\n    mutation: getMaybeTypeByName(operationTypes.mutation),\n    subscription: getMaybeTypeByName(operationTypes.subscription),\n    types: objectValues(typeMap),\n    directives: getMergedDirectives(),\n    astNode: schemaDef || schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),\n    allowedLegacyNames: allowedLegacyNames\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function getMaybeTypeByName(typeName) {\n    return typeName ? typeMap[typeName] : null;\n  }\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    existingDirectives || devAssert(0, 'schema must have default directives');\n    return existingDirectives.concat(directiveDefs.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    } else if (isScalarType(type)) {\n      return extendScalarType(type);\n    } else if (isObjectType(type)) {\n      return extendObjectType(type);\n    } else if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    } else if (isUnionType(type)) {\n      return extendUnionType(type);\n    } else if (isEnumType(type)) {\n      return extendEnumType(type);\n    } else if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // Not reachable. All possible types have been considered.\n\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendInputObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), {}, keyValMap(fieldNodes, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return astBuilder.buildInputField(field);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[type.name] || [];\n    var valueNodes = flatMap(extensions, function (node) {\n      return node.values || [];\n    });\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, {}, keyValMap(valueNodes, function (value) {\n        return value.name.value;\n      }, function (value) {\n        return astBuilder.buildEnumValue(value);\n      })),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var interfaceNodes = flatMap(extensions, function (node) {\n      return node.interfaces || [];\n    });\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var typeNodes = flatMap(extensions, function (node) {\n      return node.types || [];\n    });\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}